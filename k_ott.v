(* generated by Ott 0.25, locally-nameless lngen from: k.ott *)
Require Import Metatheory.
(** syntax *)
Definition x := var. (*r variables *)
Definition i := nat. (*r integer literals *)

Inductive t : Set :=  (*r types *)
 | t_int : t
 | t_void : t
 | t_arr (t1:t) (t2:t)
 | t_prod (t1:t) (t2:t).

Inductive p : Set :=  (*r primitives *)
 | p_plus : p
 | p_minus : p.

Definition G : Set := list (x * t).

Inductive e : Set :=  (*r annotated terms *)
 | e_ann (u5:u) (t5:t)
with u : Set :=  (*r raw terms *)
 | u_var_b (_:nat)
 | u_var_f (x5:x)
 | u_int (i5:i)
 | u_lam (t5:t) (e5:e)
 | u_app (e1:e) (e2:e)
 | u_pair (e1:e) (e2:e)
 | u_prl (e5:e)
 | u_prr (e5:e)
 | u_prim (e1:e) (p5:p) (e2:e)
 | u_if0 (e1:e) (e2:e) (e3:e)
 | u_let (e5:e) (u5:u)
 | u_halt (e5:e).

(* EXPERIMENTAL *)
(** auxiliary functions on the new list types *)
(** library functions *)
(** subrules *)
(** arities *)
(** opening up abstractions *)
Fixpoint open_u_wrt_u_rec (k:nat) (u_6:u) (u__7:u) {struct u__7}: u :=
  match u__7 with
  | (u_var_b nat) => 
      match lt_eq_lt_dec nat k with
        | inleft (left _) => u_var_b nat
        | inleft (right _) => u_6
        | inright _ => u_var_b (nat - 1)
      end
  | (u_var_f x5) => u_var_f x5
  | (u_int i5) => u_int i5
  | (u_lam t5 e5) => u_lam t5 (open_e_wrt_u_rec (S k) u_6 e5)
  | (u_app e1 e2) => u_app (open_e_wrt_u_rec k u_6 e1) (open_e_wrt_u_rec k u_6 e2)
  | (u_pair e1 e2) => u_pair (open_e_wrt_u_rec k u_6 e1) (open_e_wrt_u_rec k u_6 e2)
  | (u_prl e5) => u_prl (open_e_wrt_u_rec k u_6 e5)
  | (u_prr e5) => u_prr (open_e_wrt_u_rec k u_6 e5)
  | (u_prim e1 p5 e2) => u_prim (open_e_wrt_u_rec k u_6 e1) p5 (open_e_wrt_u_rec k u_6 e2)
  | (u_if0 e1 e2 e3) => u_if0 (open_e_wrt_u_rec k u_6 e1) (open_e_wrt_u_rec k u_6 e2) (open_e_wrt_u_rec k u_6 e3)
  | (u_let e5 u5) => u_let (open_e_wrt_u_rec k u_6 e5) (open_u_wrt_u_rec (S k) u_6 u5)
  | (u_halt e5) => u_halt (open_e_wrt_u_rec k u_6 e5)
end
with open_e_wrt_u_rec (k:nat) (u_6:u) (e_6:e) : e :=
  match e_6 with
  | (e_ann u5 t5) => e_ann (open_u_wrt_u_rec k u_6 u5) t5
end.

Definition open_u_wrt_u u_6 u__7 := open_u_wrt_u_rec 0 u__7 u_6.

Definition open_e_wrt_u u_6 e_6 := open_e_wrt_u_rec 0 e_6 u_6.

(** terms are locally-closed pre-terms *)
(** definitions *)

(* defns LC_u_e *)
Inductive lc_u : u -> Prop :=    (* defn lc_u *)
 | lc_u_var_f : forall (x5:x),
     (lc_u (u_var_f x5))
 | lc_u_int : forall (i5:i),
     (lc_u (u_int i5))
 | lc_u_lam : forall (t5:t) (e5:e),
      ( forall x5 , lc_e  ( open_e_wrt_u e5 (u_var_f x5) )  )  ->
     (lc_u (u_lam t5 e5))
 | lc_u_app : forall (e1 e2:e),
     (lc_e e1) ->
     (lc_e e2) ->
     (lc_u (u_app e1 e2))
 | lc_u_pair : forall (e1 e2:e),
     (lc_e e1) ->
     (lc_e e2) ->
     (lc_u (u_pair e1 e2))
 | lc_u_prl : forall (e5:e),
     (lc_e e5) ->
     (lc_u (u_prl e5))
 | lc_u_prr : forall (e5:e),
     (lc_e e5) ->
     (lc_u (u_prr e5))
 | lc_u_prim : forall (e1:e) (p5:p) (e2:e),
     (lc_e e1) ->
     (lc_e e2) ->
     (lc_u (u_prim e1 p5 e2))
 | lc_u_if0 : forall (e1 e2 e3:e),
     (lc_e e1) ->
     (lc_e e2) ->
     (lc_e e3) ->
     (lc_u (u_if0 e1 e2 e3))
 | lc_u_let : forall (e5:e) (u5:u),
     (lc_e e5) ->
      ( forall x5 , lc_u  ( open_u_wrt_u u5 (u_var_f x5) )  )  ->
     (lc_u (u_let e5 u5))
 | lc_u_halt : forall (e5:e),
     (lc_e e5) ->
     (lc_u (u_halt e5))
with lc_e : e -> Prop :=    (* defn lc_e *)
 | lc_e_ann : forall (u5:u) (t5:t),
     (lc_u u5) ->
     (lc_e (e_ann u5 t5)).
(** free variables *)
Fixpoint u_fv_u (u_6:u) : vars :=
  match u_6 with
  | (u_var_b nat) => {}
  | (u_var_f x5) => {{x5}}
  | (u_int i5) => {}
  | (u_lam t5 e5) => (u_fv_e e5)
  | (u_app e1 e2) => (u_fv_e e1) \u (u_fv_e e2)
  | (u_pair e1 e2) => (u_fv_e e1) \u (u_fv_e e2)
  | (u_prl e5) => (u_fv_e e5)
  | (u_prr e5) => (u_fv_e e5)
  | (u_prim e1 p5 e2) => (u_fv_e e1) \u (u_fv_e e2)
  | (u_if0 e1 e2 e3) => (u_fv_e e1) \u (u_fv_e e2) \u (u_fv_e e3)
  | (u_let e5 u5) => (u_fv_e e5) \u (u_fv_u u5)
  | (u_halt e5) => (u_fv_e e5)
end
with u_fv_e (e_6:e) : vars :=
  match e_6 with
  | (e_ann u5 t5) => (u_fv_u u5)
end.

(** substitutions *)
Fixpoint u_subst_u (u_6:u) (x_6:x) (u__7:u) {struct u__7} : u :=
  match u__7 with
  | (u_var_b nat) => u_var_b nat
  | (u_var_f x5) => (if eq_var x5 x_6 then u_6 else (u_var_f x5))
  | (u_int i5) => u_int i5
  | (u_lam t5 e5) => u_lam t5 (u_subst_e u_6 x_6 e5)
  | (u_app e1 e2) => u_app (u_subst_e u_6 x_6 e1) (u_subst_e u_6 x_6 e2)
  | (u_pair e1 e2) => u_pair (u_subst_e u_6 x_6 e1) (u_subst_e u_6 x_6 e2)
  | (u_prl e5) => u_prl (u_subst_e u_6 x_6 e5)
  | (u_prr e5) => u_prr (u_subst_e u_6 x_6 e5)
  | (u_prim e1 p5 e2) => u_prim (u_subst_e u_6 x_6 e1) p5 (u_subst_e u_6 x_6 e2)
  | (u_if0 e1 e2 e3) => u_if0 (u_subst_e u_6 x_6 e1) (u_subst_e u_6 x_6 e2) (u_subst_e u_6 x_6 e3)
  | (u_let e5 u5) => u_let (u_subst_e u_6 x_6 e5) (u_subst_u u_6 x_6 u5)
  | (u_halt e5) => u_halt (u_subst_e u_6 x_6 e5)
end
with u_subst_e (u_6:u) (x_6:x) (e_6:e) {struct e_6} : e :=
  match e_6 with
  | (e_ann u5 t5) => e_ann (u_subst_u u_6 x_6 u5) t5
end.


(** definitions *)

(* defns F *)
Inductive T_ant : G -> e -> t -> Prop :=    (* defn ant *)
 | T_ant_ann : forall (G5:G) (u5:u) (t5:t),
     T_term G5 u5 t5 ->
     T_ant G5 (e_ann u5 t5) t5
with T_term : G -> u -> t -> Prop :=    (* defn term *)
 | T_term_var : forall (G5:G) (x5:x) (t5:t),
      In ( x5 ,  t5 )  G5  ->
     T_term G5 (u_var_f x5) t5
 | T_term_int : forall (G5:G) (i5:i),
     T_term G5 (u_int i5) t_int
 | T_term_lam : forall (L:vars) (G5:G) (t1:t) (e5:e) (t2:t),
      ( forall x1 , x1 \notin  L  -> T_ant  (( x1 ,  t1 ) ::  G5 )   ( open_e_wrt_u e5 (u_var_f x1) )  t2 )  ->
     T_term G5 (u_lam t1 e5) (t_arr t1 t2)
 | T_term_app : forall (G5:G) (e1 e2:e) (t2 t1:t),
     T_ant G5 e1 (t_arr t1 t2) ->
     T_ant G5 e2 t1 ->
     T_term G5 (u_app e1 e2) t2
 | T_term_pair : forall (G5:G) (e1 e2:e) (t1 t2:t),
     T_ant G5 e1 t1 ->
     T_ant G5 e2 t2 ->
     T_term G5 (u_pair e1 e2) (t_prod t1 t2)
 | T_term_prl : forall (G5:G) (e5:e) (t1 t2:t),
     T_ant G5 e5 (t_prod t1 t2) ->
     T_term G5 (u_prl e5) t1
 | T_term_prr : forall (G5:G) (e5:e) (t2 t1:t),
     T_ant G5 e5 (t_prod t1 t2) ->
     T_term G5 (u_prr e5) t2
 | T_term_prim : forall (G5:G) (e1:e) (p5:p) (e2:e),
     T_ant G5 e1 t_int ->
     T_ant G5 e2 t_int ->
     T_term G5 (u_prim e1 p5 e2) t_int
 | T_term_if0 : forall (G5:G) (e1 e2 e3:e) (t5:t),
     T_ant G5 e1 t_int ->
     T_ant G5 e2 t5 ->
     T_ant G5 e3 t5 ->
     T_term G5 (u_if0 e1 e2 e3) t5.

(* defns K *)
Inductive K_ant : G -> e -> t -> Prop :=    (* defn ant *)
 | K_ant_ann : forall (G5:G) (u5:u) (t5:t),
     K_term G5 u5 t5 ->
     K_ant G5 (e_ann u5 t5) t5
with K_term : G -> u -> t -> Prop :=    (* defn term *)
 | K_term_var : forall (G5:G) (x5:x) (t5:t),
      In ( x5 ,  t5 )  G5  ->
     K_term G5 (u_var_f x5) t5
 | K_term_int : forall (G5:G) (i5:i),
     K_term G5 (u_int i5) t_int
 | K_term_Lam : forall (L:vars) (G5:G) (t5:t) (e5:e),
      ( forall x5 , x5 \notin  L  -> K_ant  (( x5 ,  t5 ) ::  G5 )   ( open_e_wrt_u e5 (u_var_f x5) )  t_void )  ->
     K_term G5 (u_lam t5 e5) (t_arr t5 t_void)
 | K_term_pair : forall (G5:G) (e1 e2:e) (t1 t2:t),
     K_ant G5 e1 t1 ->
     K_ant G5 e2 t2 ->
     K_term G5 (u_pair e1 e2) (t_prod t1 t2)
 | K_term_let : forall (L:vars) (G5:G) (e5:e) (u5:u) (t5:t),
     K_ant G5 e5 t5 ->
      ( forall x5 , x5 \notin  L  -> K_term  (( x5 ,  t5 ) ::  G5 )   ( open_u_wrt_u u5 (u_var_f x5) )  t_void )  ->
     K_term G5 (u_let e5 u5) t_void
 | K_term_prl : forall (G5:G) (e5:e) (t1 t2:t),
     K_ant G5 e5 (t_prod t1 t2) ->
     K_term G5 (u_prl e5) t1
 | K_term_prr : forall (G5:G) (e5:e) (t2 t1:t),
     K_ant G5 e5 (t_prod t1 t2) ->
     K_term G5 (u_prr e5) t2
 | K_term_prim : forall (G5:G) (e1:e) (p5:p) (e2:e),
     K_ant G5 e1 t_int ->
     K_ant G5 e2 t_int ->
     K_term G5 (u_prim e1 p5 e2) t_int
 | K_term_app : forall (G5:G) (e' e5:e) (t5:t),
     K_ant G5 e' (t_arr t5 t_void) ->
     K_ant G5 e5 t5 ->
     K_term G5 (u_app e' e5) t_void
 | K_term_if0 : forall (G5:G) (e_5 e1 e2:e),
     K_ant G5 e_5 t_int ->
     K_ant G5 e1 t_void ->
     K_ant G5 e2 t_void ->
     K_term G5 (u_if0 e_5 e1 e2) t_void
 | K_term_halt : forall (G5:G) (e5:e) (t5:t),
     K_ant G5 e5 t5 ->
     K_term G5 (u_halt e5) t_void.
