(* generated by Ott 0.25, locally-nameless lngen from: k.ott *)
Require Import Metatheory.
(** syntax *)
Definition a := var. (*r type variables *)
Definition x := var. (*r variables *)
Definition i := nat. (*r integer literals *)

Inductive t : Set :=  (*r types *)
 | t_var_b (_:nat)
 | t_var_f (a5:a)
 | t_int : t
 | t_void : t
 | t_arr (t1:t) (t2:t)
 | t_all (t5:t)
 | t_prod (t1:t) (t2:t).

Inductive p : Set :=  (*r primitives *)
 | p_plus : p
 | p_minus : p.

Inductive v : Set :=  (*r annotated values *)
 | v_ann (u5:u) (t5:t)
with u : Set :=  (*r values *)
 | u_var_b (_:nat)
 | u_var_f (x5:x)
 | u_int (i5:i)
 | u_lam (t5:t) (v5:v)
 | u_Lam (t5:t) (e5:e)
 | u_app (v1:v) (v2:v)
 | u_pair (v1:v) (v2:v)
 | u_prl (v5:v)
 | u_prr (v5:v)
 | u_prim (v1:v) (p5:p) (v2:v)
 | u_if0 (v1:v) (v2:v) (v3:v)
with d : Set :=  (*r declarations *)
 | d_val (v5:v)
 | d_prl (v5:v)
 | d_prr (v5:v)
 | d_prim (v1:v) (p5:p) (v2:v)
with e : Set :=  (*r terms *)
 | e_let (d5:d) (e5:e)
 | e_app (v':v) (v5:v)
 | e_if0 (v5:v) (e1:e) (e2:e)
 | e_halt (t5:t) (v5:v).

Definition D : Set := list a.

Definition G : Set := list (x * t).

(* EXPERIMENTAL *)
(** auxiliary functions on the new list types *)
(** library functions *)
(** subrules *)
(** arities *)
(** opening up abstractions *)
Fixpoint open_t_wrt_t_rec (k:nat) (s5:t) (s_6:t) {struct s_6}: t :=
  match s_6 with
  | (t_var_b nat) => 
      match lt_eq_lt_dec nat k with
        | inleft (left _) => t_var_b nat
        | inleft (right _) => s5
        | inright _ => t_var_b (nat - 1)
      end
  | (t_var_f a5) => t_var_f a5
  | t_int => t_int 
  | t_void => t_void 
  | (t_arr t1 t2) => t_arr (open_t_wrt_t_rec k s5 t1) (open_t_wrt_t_rec k s5 t2)
  | (t_all t5) => t_all (open_t_wrt_t_rec (S k) s5 t5)
  | (t_prod t1 t2) => t_prod (open_t_wrt_t_rec k s5 t1) (open_t_wrt_t_rec k s5 t2)
end.

Fixpoint open_e_wrt_u_rec (k:nat) (u5:u) (e_6:e) {struct e_6}: e :=
  match e_6 with
  | (e_let d5 e5) => e_let (open_d_wrt_u_rec k u5 d5) (open_e_wrt_u_rec (S k) u5 e5)
  | (e_app v' v5) => e_app (open_v_wrt_u_rec k u5 v') (open_v_wrt_u_rec k u5 v5)
  | (e_if0 v5 e1 e2) => e_if0 (open_v_wrt_u_rec k u5 v5) (open_e_wrt_u_rec k u5 e1) (open_e_wrt_u_rec k u5 e2)
  | (e_halt t5 v5) => e_halt t5 (open_v_wrt_u_rec k u5 v5)
end
with open_d_wrt_u_rec (k:nat) (u5:u) (d5:d) : d :=
  match d5 with
  | (d_val v5) => d_val (open_v_wrt_u_rec k u5 v5)
  | (d_prl v5) => d_prl (open_v_wrt_u_rec k u5 v5)
  | (d_prr v5) => d_prr (open_v_wrt_u_rec k u5 v5)
  | (d_prim v1 p5 v2) => d_prim (open_v_wrt_u_rec k u5 v1) p5 (open_v_wrt_u_rec k u5 v2)
end
with open_u_wrt_u_rec (k:nat) (u_6:u) (u__7:u) : u :=
  match u__7 with
  | (u_var_b nat) => 
      match lt_eq_lt_dec nat k with
        | inleft (left _) => u_var_b nat
        | inleft (right _) => u_6
        | inright _ => u_var_b (nat - 1)
      end
  | (u_var_f x5) => u_var_f x5
  | (u_int i5) => u_int i5
  | (u_lam t5 v5) => u_lam t5 (open_v_wrt_u_rec (S k) u_6 v5)
  | (u_Lam t5 e5) => u_Lam t5 (open_e_wrt_u_rec (S k) u_6 e5)
  | (u_app v1 v2) => u_app (open_v_wrt_u_rec k u_6 v1) (open_v_wrt_u_rec k u_6 v2)
  | (u_pair v1 v2) => u_pair (open_v_wrt_u_rec k u_6 v1) (open_v_wrt_u_rec k u_6 v2)
  | (u_prl v5) => u_prl (open_v_wrt_u_rec k u_6 v5)
  | (u_prr v5) => u_prr (open_v_wrt_u_rec k u_6 v5)
  | (u_prim v1 p5 v2) => u_prim (open_v_wrt_u_rec k u_6 v1) p5 (open_v_wrt_u_rec k u_6 v2)
  | (u_if0 v1 v2 v3) => u_if0 (open_v_wrt_u_rec k u_6 v1) (open_v_wrt_u_rec k u_6 v2) (open_v_wrt_u_rec k u_6 v3)
end
with open_v_wrt_u_rec (k:nat) (u_6:u) (v5:v) : v :=
  match v5 with
  | (v_ann u5 t5) => v_ann (open_u_wrt_u_rec k u_6 u5) t5
end.

Fixpoint open_e_wrt_t_rec (k:nat) (s5:t) (e_6:e) {struct e_6}: e :=
  match e_6 with
  | (e_let d5 e5) => e_let (open_d_wrt_t_rec k s5 d5) (open_e_wrt_t_rec k s5 e5)
  | (e_app v' v5) => e_app (open_v_wrt_t_rec k s5 v') (open_v_wrt_t_rec k s5 v5)
  | (e_if0 v5 e1 e2) => e_if0 (open_v_wrt_t_rec k s5 v5) (open_e_wrt_t_rec k s5 e1) (open_e_wrt_t_rec k s5 e2)
  | (e_halt t5 v5) => e_halt (open_t_wrt_t_rec k s5 t5) (open_v_wrt_t_rec k s5 v5)
end
with open_d_wrt_t_rec (k:nat) (s5:t) (d5:d) : d :=
  match d5 with
  | (d_val v5) => d_val (open_v_wrt_t_rec k s5 v5)
  | (d_prl v5) => d_prl (open_v_wrt_t_rec k s5 v5)
  | (d_prr v5) => d_prr (open_v_wrt_t_rec k s5 v5)
  | (d_prim v1 p5 v2) => d_prim (open_v_wrt_t_rec k s5 v1) p5 (open_v_wrt_t_rec k s5 v2)
end
with open_u_wrt_t_rec (k:nat) (s5:t) (u_6:u) : u :=
  match u_6 with
  | (u_var_b nat) => u_var_b nat
  | (u_var_f x5) => u_var_f x5
  | (u_int i5) => u_int i5
  | (u_lam t5 v5) => u_lam (open_t_wrt_t_rec k s5 t5) (open_v_wrt_t_rec k s5 v5)
  | (u_Lam t5 e5) => u_Lam (open_t_wrt_t_rec k s5 t5) (open_e_wrt_t_rec k s5 e5)
  | (u_app v1 v2) => u_app (open_v_wrt_t_rec k s5 v1) (open_v_wrt_t_rec k s5 v2)
  | (u_pair v1 v2) => u_pair (open_v_wrt_t_rec k s5 v1) (open_v_wrt_t_rec k s5 v2)
  | (u_prl v5) => u_prl (open_v_wrt_t_rec k s5 v5)
  | (u_prr v5) => u_prr (open_v_wrt_t_rec k s5 v5)
  | (u_prim v1 p5 v2) => u_prim (open_v_wrt_t_rec k s5 v1) p5 (open_v_wrt_t_rec k s5 v2)
  | (u_if0 v1 v2 v3) => u_if0 (open_v_wrt_t_rec k s5 v1) (open_v_wrt_t_rec k s5 v2) (open_v_wrt_t_rec k s5 v3)
end
with open_v_wrt_t_rec (k:nat) (s5:t) (v5:v) : v :=
  match v5 with
  | (v_ann u5 t5) => v_ann (open_u_wrt_t_rec k s5 u5) (open_t_wrt_t_rec k s5 t5)
end.

Definition open_u_wrt_u u_6 u__7 := open_u_wrt_u_rec 0 u__7 u_6.

Definition open_e_wrt_t s5 e_6 := open_e_wrt_t_rec 0 e_6 s5.

Definition open_v_wrt_u u_6 v5 := open_v_wrt_u_rec 0 v5 u_6.

Definition open_u_wrt_t s5 u_6 := open_u_wrt_t_rec 0 u_6 s5.

Definition open_d_wrt_u u5 d5 := open_d_wrt_u_rec 0 d5 u5.

Definition open_e_wrt_u u5 e_6 := open_e_wrt_u_rec 0 e_6 u5.

Definition open_v_wrt_t s5 v5 := open_v_wrt_t_rec 0 v5 s5.

Definition open_t_wrt_t s5 s_6 := open_t_wrt_t_rec 0 s_6 s5.

Definition open_d_wrt_t s5 d5 := open_d_wrt_t_rec 0 d5 s5.

(** terms are locally-closed pre-terms *)
(** definitions *)

(* defns LC_t *)
Inductive lc_t : t -> Prop :=    (* defn lc_t *)
 | lc_t_var_f : forall (a5:a),
     (lc_t (t_var_f a5))
 | lc_t_int : 
     (lc_t t_int)
 | lc_t_void : 
     (lc_t t_void)
 | lc_t_arr : forall (t1 t2:t),
     (lc_t t1) ->
     (lc_t t2) ->
     (lc_t (t_arr t1 t2))
 | lc_t_all : forall (t5:t),
      ( forall a5 , lc_t  ( open_t_wrt_t t5 (t_var_f a5) )  )  ->
     (lc_t (t_all t5))
 | lc_t_prod : forall (t1 t2:t),
     (lc_t t1) ->
     (lc_t t2) ->
     (lc_t (t_prod t1 t2)).

(* defns LC_e_d_u_v *)
Inductive lc_e : e -> Prop :=    (* defn lc_e *)
 | lc_e_let : forall (d5:d) (e5:e),
     (lc_d d5) ->
      ( forall x5 , lc_e  ( open_e_wrt_u e5 (u_var_f x5) )  )  ->
     (lc_e (e_let d5 e5))
 | lc_e_app : forall (v' v5:v),
     (lc_v v') ->
     (lc_v v5) ->
     (lc_e (e_app v' v5))
 | lc_e_if0 : forall (v5:v) (e1 e2:e),
     (lc_v v5) ->
     (lc_e e1) ->
     (lc_e e2) ->
     (lc_e (e_if0 v5 e1 e2))
 | lc_e_halt : forall (t5:t) (v5:v),
     (lc_t t5) ->
     (lc_v v5) ->
     (lc_e (e_halt t5 v5))
with lc_d : d -> Prop :=    (* defn lc_d *)
 | lc_d_val : forall (v5:v),
     (lc_v v5) ->
     (lc_d (d_val v5))
 | lc_d_prl : forall (v5:v),
     (lc_v v5) ->
     (lc_d (d_prl v5))
 | lc_d_prr : forall (v5:v),
     (lc_v v5) ->
     (lc_d (d_prr v5))
 | lc_d_prim : forall (v1:v) (p5:p) (v2:v),
     (lc_v v1) ->
     (lc_v v2) ->
     (lc_d (d_prim v1 p5 v2))
with lc_u : u -> Prop :=    (* defn lc_u *)
 | lc_u_var_f : forall (x5:x),
     (lc_u (u_var_f x5))
 | lc_u_int : forall (i5:i),
     (lc_u (u_int i5))
 | lc_u_lam : forall (t5:t) (v5:v),
     (lc_t t5) ->
      ( forall x5 , lc_v  ( open_v_wrt_u v5 (u_var_f x5) )  )  ->
     (lc_u (u_lam t5 v5))
 | lc_u_Lam : forall (t5:t) (e5:e),
     (lc_t t5) ->
      ( forall x5 , lc_e  ( open_e_wrt_u e5 (u_var_f x5) )  )  ->
     (lc_u (u_Lam t5 e5))
 | lc_u_app : forall (v1 v2:v),
     (lc_v v1) ->
     (lc_v v2) ->
     (lc_u (u_app v1 v2))
 | lc_u_pair : forall (v1 v2:v),
     (lc_v v1) ->
     (lc_v v2) ->
     (lc_u (u_pair v1 v2))
 | lc_u_prl : forall (v5:v),
     (lc_v v5) ->
     (lc_u (u_prl v5))
 | lc_u_prr : forall (v5:v),
     (lc_v v5) ->
     (lc_u (u_prr v5))
 | lc_u_prim : forall (v1:v) (p5:p) (v2:v),
     (lc_v v1) ->
     (lc_v v2) ->
     (lc_u (u_prim v1 p5 v2))
 | lc_u_if0 : forall (v1 v2 v3:v),
     (lc_v v1) ->
     (lc_v v2) ->
     (lc_v v3) ->
     (lc_u (u_if0 v1 v2 v3))
with lc_v : v -> Prop :=    (* defn lc_v *)
 | lc_v_ann : forall (u5:u) (t5:t),
     (lc_u u5) ->
     (lc_t t5) ->
     (lc_v (v_ann u5 t5)).
(** free variables *)
Fixpoint tt_fv_t (s5:t) : vars :=
  match s5 with
  | (t_var_b nat) => {}
  | (t_var_f a5) => {{a5}}
  | t_int => {}
  | t_void => {}
  | (t_arr t1 t2) => (tt_fv_t t1) \u (tt_fv_t t2)
  | (t_all t5) => (tt_fv_t t5)
  | (t_prod t1 t2) => (tt_fv_t t1) \u (tt_fv_t t2)
end.

Fixpoint tt_fv_e (e_6:e) : vars :=
  match e_6 with
  | (e_let d5 e5) => (tt_fv_d d5) \u (tt_fv_e e5)
  | (e_app v' v5) => (tt_fv_v v') \u (tt_fv_v v5)
  | (e_if0 v5 e1 e2) => (tt_fv_v v5) \u (tt_fv_e e1) \u (tt_fv_e e2)
  | (e_halt t5 v5) => (tt_fv_t t5) \u (tt_fv_v v5)
end
with tt_fv_d (d5:d) : vars :=
  match d5 with
  | (d_val v5) => (tt_fv_v v5)
  | (d_prl v5) => (tt_fv_v v5)
  | (d_prr v5) => (tt_fv_v v5)
  | (d_prim v1 p5 v2) => (tt_fv_v v1) \u (tt_fv_v v2)
end
with tt_fv_u (u_6:u) : vars :=
  match u_6 with
  | (u_var_b nat) => {}
  | (u_var_f x5) => {}
  | (u_int i5) => {}
  | (u_lam t5 v5) => (tt_fv_t t5) \u (tt_fv_v v5)
  | (u_Lam t5 e5) => (tt_fv_t t5) \u (tt_fv_e e5)
  | (u_app v1 v2) => (tt_fv_v v1) \u (tt_fv_v v2)
  | (u_pair v1 v2) => (tt_fv_v v1) \u (tt_fv_v v2)
  | (u_prl v5) => (tt_fv_v v5)
  | (u_prr v5) => (tt_fv_v v5)
  | (u_prim v1 p5 v2) => (tt_fv_v v1) \u (tt_fv_v v2)
  | (u_if0 v1 v2 v3) => (tt_fv_v v1) \u (tt_fv_v v2) \u (tt_fv_v v3)
end
with tt_fv_v (v5:v) : vars :=
  match v5 with
  | (v_ann u5 t5) => (tt_fv_u u5) \u (tt_fv_t t5)
end.

Fixpoint e_fv_e (e_6:e) : vars :=
  match e_6 with
  | (e_let d5 e5) => (e_fv_d d5) \u (e_fv_e e5)
  | (e_app v' v5) => (e_fv_v v') \u (e_fv_v v5)
  | (e_if0 v5 e1 e2) => (e_fv_v v5) \u (e_fv_e e1) \u (e_fv_e e2)
  | (e_halt t5 v5) => (e_fv_v v5)
end
with e_fv_d (d5:d) : vars :=
  match d5 with
  | (d_val v5) => (e_fv_v v5)
  | (d_prl v5) => (e_fv_v v5)
  | (d_prr v5) => (e_fv_v v5)
  | (d_prim v1 p5 v2) => (e_fv_v v1) \u (e_fv_v v2)
end
with e_fv_u (u_6:u) : vars :=
  match u_6 with
  | (u_var_b nat) => {}
  | (u_var_f x5) => {{x5}}
  | (u_int i5) => {}
  | (u_lam t5 v5) => (e_fv_v v5)
  | (u_Lam t5 e5) => (e_fv_e e5)
  | (u_app v1 v2) => (e_fv_v v1) \u (e_fv_v v2)
  | (u_pair v1 v2) => (e_fv_v v1) \u (e_fv_v v2)
  | (u_prl v5) => (e_fv_v v5)
  | (u_prr v5) => (e_fv_v v5)
  | (u_prim v1 p5 v2) => (e_fv_v v1) \u (e_fv_v v2)
  | (u_if0 v1 v2 v3) => (e_fv_v v1) \u (e_fv_v v2) \u (e_fv_v v3)
end
with e_fv_v (v5:v) : vars :=
  match v5 with
  | (v_ann u5 t5) => (e_fv_u u5)
end.

(** substitutions *)
Fixpoint t_subst_t (s5:t) (a_6:a) (s_6:t) {struct s_6} : t :=
  match s_6 with
  | (t_var_b nat) => t_var_b nat
  | (t_var_f a5) => (if eq_var a5 a_6 then s5 else (t_var_f a5))
  | t_int => t_int 
  | t_void => t_void 
  | (t_arr t1 t2) => t_arr (t_subst_t s5 a_6 t1) (t_subst_t s5 a_6 t2)
  | (t_all t5) => t_all (t_subst_t s5 a_6 t5)
  | (t_prod t1 t2) => t_prod (t_subst_t s5 a_6 t1) (t_subst_t s5 a_6 t2)
end.

Fixpoint e_subst_e (u5:u) (x5:x) (e_6:e) {struct e_6} : e :=
  match e_6 with
  | (e_let d5 e5) => e_let (e_subst_d u5 x5 d5) (e_subst_e u5 x5 e5)
  | (e_app v' v5) => e_app (e_subst_v u5 x5 v') (e_subst_v u5 x5 v5)
  | (e_if0 v5 e1 e2) => e_if0 (e_subst_v u5 x5 v5) (e_subst_e u5 x5 e1) (e_subst_e u5 x5 e2)
  | (e_halt t5 v5) => e_halt t5 (e_subst_v u5 x5 v5)
end
with e_subst_d (u5:u) (x5:x) (d5:d) {struct d5} : d :=
  match d5 with
  | (d_val v5) => d_val (e_subst_v u5 x5 v5)
  | (d_prl v5) => d_prl (e_subst_v u5 x5 v5)
  | (d_prr v5) => d_prr (e_subst_v u5 x5 v5)
  | (d_prim v1 p5 v2) => d_prim (e_subst_v u5 x5 v1) p5 (e_subst_v u5 x5 v2)
end
with e_subst_u (u_6:u) (x_6:x) (u__7:u) {struct u__7} : u :=
  match u__7 with
  | (u_var_b nat) => u_var_b nat
  | (u_var_f x5) => (if eq_var x5 x_6 then u_6 else (u_var_f x5))
  | (u_int i5) => u_int i5
  | (u_lam t5 v5) => u_lam t5 (e_subst_v u_6 x_6 v5)
  | (u_Lam t5 e5) => u_Lam t5 (e_subst_e u_6 x_6 e5)
  | (u_app v1 v2) => u_app (e_subst_v u_6 x_6 v1) (e_subst_v u_6 x_6 v2)
  | (u_pair v1 v2) => u_pair (e_subst_v u_6 x_6 v1) (e_subst_v u_6 x_6 v2)
  | (u_prl v5) => u_prl (e_subst_v u_6 x_6 v5)
  | (u_prr v5) => u_prr (e_subst_v u_6 x_6 v5)
  | (u_prim v1 p5 v2) => u_prim (e_subst_v u_6 x_6 v1) p5 (e_subst_v u_6 x_6 v2)
  | (u_if0 v1 v2 v3) => u_if0 (e_subst_v u_6 x_6 v1) (e_subst_v u_6 x_6 v2) (e_subst_v u_6 x_6 v3)
end
with e_subst_v (u_6:u) (x5:x) (v5:v) {struct v5} : v :=
  match v5 with
  | (v_ann u5 t5) => v_ann (e_subst_u u_6 x5 u5) t5
end.

Fixpoint t_subst_e (s5:t) (a5:a) (e_6:e) {struct e_6} : e :=
  match e_6 with
  | (e_let d5 e5) => e_let (t_subst_d s5 a5 d5) (t_subst_e s5 a5 e5)
  | (e_app v' v5) => e_app (t_subst_v s5 a5 v') (t_subst_v s5 a5 v5)
  | (e_if0 v5 e1 e2) => e_if0 (t_subst_v s5 a5 v5) (t_subst_e s5 a5 e1) (t_subst_e s5 a5 e2)
  | (e_halt t5 v5) => e_halt (t_subst_t s5 a5 t5) (t_subst_v s5 a5 v5)
end
with t_subst_d (s5:t) (a5:a) (d5:d) {struct d5} : d :=
  match d5 with
  | (d_val v5) => d_val (t_subst_v s5 a5 v5)
  | (d_prl v5) => d_prl (t_subst_v s5 a5 v5)
  | (d_prr v5) => d_prr (t_subst_v s5 a5 v5)
  | (d_prim v1 p5 v2) => d_prim (t_subst_v s5 a5 v1) p5 (t_subst_v s5 a5 v2)
end
with t_subst_u (s5:t) (a5:a) (u_6:u) {struct u_6} : u :=
  match u_6 with
  | (u_var_b nat) => u_var_b nat
  | (u_var_f x5) => u_var_f x5
  | (u_int i5) => u_int i5
  | (u_lam t5 v5) => u_lam (t_subst_t s5 a5 t5) (t_subst_v s5 a5 v5)
  | (u_Lam t5 e5) => u_Lam (t_subst_t s5 a5 t5) (t_subst_e s5 a5 e5)
  | (u_app v1 v2) => u_app (t_subst_v s5 a5 v1) (t_subst_v s5 a5 v2)
  | (u_pair v1 v2) => u_pair (t_subst_v s5 a5 v1) (t_subst_v s5 a5 v2)
  | (u_prl v5) => u_prl (t_subst_v s5 a5 v5)
  | (u_prr v5) => u_prr (t_subst_v s5 a5 v5)
  | (u_prim v1 p5 v2) => u_prim (t_subst_v s5 a5 v1) p5 (t_subst_v s5 a5 v2)
  | (u_if0 v1 v2 v3) => u_if0 (t_subst_v s5 a5 v1) (t_subst_v s5 a5 v2) (t_subst_v s5 a5 v3)
end
with t_subst_v (s5:t) (a5:a) (v5:v) {struct v5} : v :=
  match v5 with
  | (v_ann u5 t5) => v_ann (t_subst_u s5 a5 u5) (t_subst_t s5 a5 t5)
end.


(** definitions *)

(* defns F *)
Inductive F_type : D -> t -> Prop :=    (* defn type *)
 | F_type_var : forall (D5:D) (a5:a),
      In  a5   D5  ->
     F_type D5 (t_var_f a5)
 | F_type_int : forall (D5:D),
     F_type D5 t_int
 | F_type_arr : forall (D5:D) (t1 t2:t),
     F_type D5 t1 ->
     F_type D5 t2 ->
     F_type D5 (t_arr t1 t2)
 | F_type_all : forall (L:vars) (D5:D) (t5:t),
      ( forall a5 , a5 \notin  L  -> F_type  ( a5  ::  D5 )   ( open_t_wrt_t t5 (t_var_f a5) )  )  ->
     F_type D5 (t_all t5)
 | F_type_prod : forall (D5:D) (t1 t2:t),
     F_type D5 t1 ->
     F_type D5 t2 ->
     F_type D5 (t_prod t1 t2)
with F_anv : D -> G -> v -> t -> Prop :=    (* defn anv *)
 | F_anv_ann : forall (D5:D) (G5:G) (u5:u) (t5:t),
     F_value D5 G5 u5 t5 ->
     F_anv D5 G5 (v_ann u5 t5) t5
with F_value : D -> G -> u -> t -> Prop :=    (* defn value *)
 | F_value_var : forall (D5:D) (G5:G) (x5:x) (t5:t),
     F_type D5 t5 ->
      In ( x5 ,  t5 )  G5  ->
     F_value D5 G5 (u_var_f x5) t5
 | F_value_int : forall (D5:D) (G5:G) (i5:i),
     F_value D5 G5 (u_int i5) t_int
 | F_value_lam : forall (L:vars) (D5:D) (G5:G) (t1:t) (v5:v) (t2:t),
     F_type D5 t1 ->
      ( forall x1 , x1 \notin  L  -> F_anv D5  (( x1 ,  t1 ) ::  G5 )   ( open_v_wrt_u v5 (u_var_f x1) )  t2 )  ->
     F_value D5 G5 (u_lam t1 v5) (t_arr t1 t2)
 | F_value_app : forall (D5:D) (G5:G) (v1 v2:v) (t2 t1:t),
     F_anv D5 G5 v1 (t_arr t1 t2) ->
     F_anv D5 G5 v2 t1 ->
     F_value D5 G5 (u_app v1 v2) t2
 | F_value_pair : forall (D5:D) (G5:G) (v1 v2:v) (t1 t2:t),
     F_anv D5 G5 v1 t1 ->
     F_anv D5 G5 v2 t2 ->
     F_value D5 G5 (u_pair v1 v2) (t_prod t1 t2)
 | F_value_prl : forall (D5:D) (G5:G) (v5:v) (t1 t2:t),
     F_anv D5 G5 v5 (t_prod t1 t2) ->
     F_value D5 G5 (u_prl v5) t1
 | F_value_prr : forall (D5:D) (G5:G) (v5:v) (t2 t1:t),
     F_anv D5 G5 v5 (t_prod t1 t2) ->
     F_value D5 G5 (u_prr v5) t2
 | F_value_prim : forall (D5:D) (G5:G) (v1:v) (p5:p) (v2:v),
     F_anv D5 G5 v1 t_int ->
     F_anv D5 G5 v2 t_int ->
     F_value D5 G5 (u_prim v1 p5 v2) t_int
 | F_value_if0 : forall (D5:D) (G5:G) (v1 v2 v3:v) (t5:t),
     F_anv D5 G5 v1 t_int ->
     F_anv D5 G5 v2 t5 ->
     F_anv D5 G5 v3 t5 ->
     F_value D5 G5 (u_if0 v1 v2 v3) t5.

(* defns K *)
Inductive K_type : D -> t -> Prop :=    (* defn type *)
 | K_type_var : forall (D5:D) (a5:a),
      In  a5   D5  ->
     K_type D5 (t_var_f a5)
 | K_type_int : forall (D5:D),
     K_type D5 t_int
 | K_type_arr : forall (D5:D) (t5:t),
     K_type D5 t5 ->
     K_type D5 (t_arr t5 t_void)
 | K_type_prod : forall (D5:D) (t1 t2:t),
     K_type D5 t1 ->
     K_type D5 t2 ->
     K_type D5 (t_prod t1 t2)
with K_anv : D -> G -> v -> t -> Prop :=    (* defn anv *)
 | K_anv_ann : forall (D5:D) (G5:G) (u5:u) (t5:t),
     K_value D5 G5 u5 t5 ->
     K_anv D5 G5 (v_ann u5 t5) t5
with K_value : D -> G -> u -> t -> Prop :=    (* defn value *)
 | K_value_var : forall (D5:D) (G5:G) (x5:x) (t5:t),
     K_type D5 t5 ->
      In ( x5 ,  t5 )  G5  ->
     K_value D5 G5 (u_var_f x5) t5
 | K_value_int : forall (D5:D) (G5:G) (i5:i),
     K_value D5 G5 (u_int i5) t_int
 | K_value_Lam : forall (L:vars) (D5:D) (G5:G) (t5:t) (e5:e),
      ( forall x5 , x5 \notin  L  -> K_term D5  (( x5 ,  t5 ) ::  G5 )   ( open_e_wrt_u e5 (u_var_f x5) )  )  ->
     K_value D5 G5 (u_Lam t5 e5) (t_arr t5 t_void)
 | K_value_pair : forall (D5:D) (G5:G) (v1 v2:v) (t1 t2:t),
     K_anv D5 G5 v1 t1 ->
     K_anv D5 G5 v2 t2 ->
     K_value D5 G5 (u_pair v1 v2) (t_prod t1 t2)
with K_term : D -> G -> e -> Prop :=    (* defn term *)
 | K_term_let : forall (L:vars) (D5:D) (G5:G) (v5:v) (e5:e) (t5:t),
     K_anv D5 G5 v5 t5 ->
      ( forall x5 , x5 \notin  L  -> K_term D5  (( x5 ,  t5 ) ::  G5 )   ( open_e_wrt_u e5 (u_var_f x5) )  )  ->
     K_term D5 G5 (e_let (d_val v5) e5)
 | K_term_prl : forall (L:vars) (D5:D) (G5:G) (v5:v) (e5:e) (t1 t2:t),
     K_anv D5 G5 v5 (t_prod t1 t2) ->
      ( forall x5 , x5 \notin  L  -> K_term D5  (( x5 ,  t1 ) ::  G5 )   ( open_e_wrt_u e5 (u_var_f x5) )  )  ->
     K_term D5 G5 (e_let (d_prl v5) e5)
 | K_term_prr : forall (L:vars) (D5:D) (G5:G) (v5:v) (e5:e) (t1 t2:t),
     K_anv D5 G5 v5 (t_prod t1 t2) ->
      ( forall x5 , x5 \notin  L  -> K_term D5  (( x5 ,  t2 ) ::  G5 )   ( open_e_wrt_u e5 (u_var_f x5) )  )  ->
     K_term D5 G5 (e_let (d_prr v5) e5)
 | K_term_prim : forall (L:vars) (D5:D) (G5:G) (v1:v) (p5:p) (v2:v) (e5:e),
     K_anv D5 G5 v1 t_int ->
     K_anv D5 G5 v2 t_int ->
      ( forall x5 , x5 \notin  L  -> K_term D5  (( x5 ,  t_int ) ::  G5 )   ( open_e_wrt_u e5 (u_var_f x5) )  )  ->
     K_term D5 G5 (e_let (d_prim v1 p5 v2) e5)
 | K_term_app : forall (D5:D) (G5:G) (v' v5:v) (t5:t),
     K_anv D5 G5 v' (t_arr t5 t_void) ->
     K_anv D5 G5 v5 t5 ->
     K_term D5 G5 (e_app v' v5)
 | K_term_if0 : forall (D5:D) (G5:G) (v5:v) (e1 e2:e),
     K_anv D5 G5 v5 t_int ->
     K_term D5 G5 e1 ->
     K_term D5 G5 e2 ->
     K_term D5 G5 (e_if0 v5 e1 e2)
 | K_term_halt : forall (D5:D) (G5:G) (t5:t) (v5:v),
     K_anv D5 G5 v5 t5 ->
     K_term D5 G5 (e_halt t5 v5).


(** infrastructure *)
Hint Constructors type anv value type anv value term lc_t lc_e lc_d lc_u lc_v.


