metavar a {{ tex \alpha }} ::= {{ com type variables }}
{{ repr-locally-nameless }}
metavar x ::= {{ com variables }}
{{ repr-locally-nameless }}
metavar i ::= {{ com integer literals }} {{ coq nat }}

grammar
t {{ tex \tau }}, s {{ tex \sigma }} :: 't_' ::= {{ com types }}
| a                 ::   :: var
| int               ::   :: int
| void              ::   :: void
| t1 -> t2          ::   :: arr
| all a . t         ::   :: all (+ bind a in t +)
| t1 * t2           ::   :: prod
| ( t )             :: S :: par {{ coq ([[t]]) }}
| t' [ t / a ]      :: M :: sub {{ coq (open_t_wrt_t [[ a t' ]][[t]]) }}

e :: 'e_' ::= {{ com annotated terms }}
| u t :: :: ann {{ tex [[u]]^[[t]] }}
| e [ u / x ] :: M :: sub {{ coq (open_e_wrt_u [[x e]] [[u]]) }}

u :: 'u_' ::= {{ com raw terms }}
| x             ::   :: var
| i             ::   :: int
| \ ( x : t ) . e :: :: lam (+ bind x in e +)
| e1 e2         ::   :: app
| e1 * e2       ::   :: pair
| e prl         ::   :: prl
| e prr         ::   :: prr
| e1 p e2       ::   :: prim
| if0 ( e1 , e2 , e3 ) :: :: if0
| let x = e in u ::  :: let (+ bind x in u +)
| halt e        ::   :: halt
| ( u )         :: S :: par {{ coq ([[u]]) }}
| u' [ u / x ]  :: M :: sub {{ coq (open_u_wrt_u [[x u']] [[u]]) }}

p :: 'p_' ::= {{ com primitives }}
| + :: :: plus
| - :: :: minus

substitutions
  single t a :: t_subst
  single e x :: e_subst
  single u x :: u_subst

freevars
  e x :: e_fv
  u x :: u_fv
  t a :: tt_fv

grammar
D {{ tex \Delta }} :: 'd_' ::= {{ com type contexts }} {{ coq list a }}
|       :: :: empty {{ coq [] }}
| D , a :: :: cons  {{ coq ([[a]] :: [[D]]) }}

G {{ tex \Gamma }} :: 'g_' ::= {{ com value contexts }} {{ coq list (x * t) }}
|           :: :: empty {{ coq [] }}
| G , x : t :: :: cons  {{ coq (([[x]], [[t]]) :: [[G]]) }}

terminals :: terminals_ ::=
| int :: :: int {{ tex \mathbb Z }}
| -> :: :: to {{ tex \to }}
| all :: :: forall {{ tex \forall }}
| void :: :: void {{ tex \mathtt{void} }}
| * :: :: prod {{ tex \times }}
| \ :: :: lambda {{ tex \lambda }}
| fix :: :: fix {{ tex \mathsf{fix} }}
| prl :: :: prl {{ tex \cdot\mathtt l }}
| prr :: :: prr {{ tex \cdot\mathtt r }}
| let :: :: let {{ tex \mathsf{let} }}
| in :: :: In {{ tex \mathsf{in} }}
| if0 :: :: if0 {{ tex \mathsf{if0} }}
| halt :: :: halt {{ tex \mathsf{halt} }}
| \in :: :: in {{ tex \in }}
| |-F :: :: turnstileF {{ tex \vdash_\mathrm F }}
| |-K :: :: turnstileK {{ tex \vdash_\mathrm K }}

formula :: formula_ ::=
| judgement :: :: judgement
| a \in D :: :: inD {{ coq In [[a]] [[D]] }}
| G ( x ) = t :: :: inG {{ coq In ([[x]], [[t]]) [[G]] }}

defns
F :: 'F_' ::=

defn
D |-F t :: :: type :: 'type_' {{ com type formation }}
by

a \in D
------- :: var
D |-F a

--------- :: int
D |-F int

D |-F t1
D |-F t2
-------------- :: arr
D |-F t1 -> t2

D , a |-F t
--------------- :: all
D |-F all a . t

D |-F t1
D |-F t2
------------- :: prod
D |-F t1 * t2

defn
D ; G |-F e : t :: :: ant :: 'ant_' {{ com annotated typing }}
by

D ; G |-F u : t
----------------- :: ann
D ; G |-F u t : t

defn
D ; G |-F u : t :: :: term :: 'term_' {{ com typing }}
by

D |-F t
G ( x ) = t
--------------- :: var
D ; G |-F x : t

----------------- :: int
D ; G |-F i : int

D |-F t1
D ; G , x1 : t1 |-F e : t2
----------------------------------------------- :: lam
D ; G |-F \ ( x1 : t1 ) . e : t1 -> t2

D ; G |-F e1 : t1 -> t2
D ; G |-F e2 : t1
----------------------- :: app
D ; G |-F e1 e2 : t2

D ; G |-F e1 : t1
D ; G |-F e2 : t2
--------------------------- :: pair
D ; G |-F e1 * e2 : t1 * t2

D ; G |-F e : t1 * t2
--------------------- :: prl
D ; G |-F e prl : t1

D ; G |-F e : t1 * t2
--------------------- :: prr
D ; G |-F e prr : t2

D ; G |-F e1 : int
D ; G |-F e2 : int
----------------------- :: prim
D ; G |-F e1 p e2 : int

D ; G |-F e1 : int
D ; G |-F e2 : t
D ; G |-F e3 : t
---------------------------------- :: if0
D ; G |-F if0 ( e1 , e2 , e3 ) : t

defns
K :: 'K_' ::=

defn
D |-K t :: :: type :: 'type_' {{ com type formation }}
by

a \in D
------- :: var
D |-K a

--------- :: int
D |-K int

D |-K t
--------------- :: arr
D |-K t -> void

D |-K t1
D |-K t2
------------- :: prod
D |-K t1 * t2

defn
D ; G |-K e : t :: :: ant :: 'ant_' {{ com annotated typing }}
by
D ; G |-K u : t
----------------- :: ann
D ; G |-K u t : t

defn
D ; G |-K u : t :: :: term :: 'term_' {{ com typing }}
by

D |-K t
G ( x ) = t
--------------- :: var
D ; G |-K x : t

----------------- :: int
D ; G |-K i : int

D ; G , x : t |-K e : void
------------------------------------- :: Lam
D ; G |-K \ ( x : t ) . e : t -> void

D ; G |-K e1 : t1
D ; G |-K e2 : t2
--------------------------- :: pair
D ; G |-K e1 * e2 : t1 * t2

D ; G |-K e : t
D ; G , x : t |-K u : void
------------------------ :: let
D ; G |-K let x = e in u : void

D ; G |-K e : t1 * t2
---------------------------- :: prl
D ; G |-K e prl : t1

D ; G |-K e : t1 * t2
---------------------------- :: prr
D ; G |-K e prr : t2

D ; G |-K e1 : int
D ; G |-K e2 : int
------------------------------ :: prim
D ; G |-K e1 p e2 : int

D ; G |-K e' : t -> void
D ; G |-K e : t
------------------------ :: app
D ; G |-K e' e : void

D ; G |-K e : int
D ; G |-K e1 : void
D ; G |-K e2 : void
----------------------------- :: if0
D ; G |-K if0 ( e , e1 , e2 ) : void

D ; G |-K e : t
---------------------- :: halt
D ; G |-K halt e : void

parsing
t_all <= t_arr

