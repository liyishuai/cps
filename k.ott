metavar a {{ tex \alpha }} ::= {{ com type variables }}
{{ repr-locally-nameless }}
metavar x ::= {{ com variables }}
{{ repr-locally-nameless }}
metavar i ::= {{ com integer literals }} {{ coq nat }}

grammar
t {{ tex \tau }}, s {{ tex \sigma }} :: 't_' ::= {{ com types }}
| a                 ::   :: var
| int               ::   :: int
| void              ::   :: void
| t1 -> t2          ::   :: arr
| all a . t         ::   :: all (+ bind a in t +)
| t1 * t2           ::   :: prod
| ( t )             :: S :: par {{ coq ([[t]]) }}
| t' [ t / a ]      :: M :: sub {{ coq (open_t_wrt_t [[ a t' ]][[t]]) }}

v :: 'v_' ::= {{ com annotated values }}
| u t :: :: ann {{ tex [[u]]^[[t]] }}

u :: 'u_' ::= {{ com values }}
| x             ::   :: var
| i             ::   :: int
| \ ( x : t ) . v :: :: lam (+ bind x in v +)
| \ ( x : t ) . e :: :: Lam (+ bind x in e +)
| v1 v2         ::   :: app
| v1 * v2       ::   :: pair
| v prl         ::   :: prl
| v prr         ::   :: prr
| v1 p v2       ::   :: prim
| if0 ( v1 , v2 , v3 ) :: :: if0
| ( u )         :: S :: par {{ coq ([[u]]) }}

p :: 'p_' ::= {{ com primitives }}
| + :: :: plus
| - :: :: minus

d :: 'd_' ::= {{ com declarations }}
| v       :: :: val  
| v prl   :: :: prl  
| v prr   :: :: prr  
| v1 p v2 :: :: prim 

e :: 'e_' ::= {{ com terms }}
| let x = d in e      :: :: let
  (+ bind x in e +)
| v' ( v )            :: :: app
| if0 ( v , e1 , e2 ) :: :: if0
| halt [ t ] v        :: :: halt

substitutions
  single t a :: t_subst
  single u x :: e_subst
  single u a :: et_subst

freevars
  u x :: e_fv
  u a :: t_fv
  t a :: tt_fv

grammar
D {{ tex \Delta }} :: 'd_' ::= {{ com type contexts }} {{ coq list a }}
|       :: :: empty {{ coq [] }}
| D , a :: :: cons  {{ coq ([[a]] :: [[D]]) }}

G {{ tex \Gamma }} :: 'g_' ::= {{ com value contexts }} {{ coq list (x * t) }}
|           :: :: empty {{ coq [] }}
| G , x : t :: :: cons  {{ coq (([[x]], [[t]]) :: [[G]]) }}

terminals :: terminals_ ::=
| int :: :: int {{ tex \mathbb Z }}
| -> :: :: to {{ tex \to }}
| all :: :: forall {{ tex \forall }}
| void :: :: void {{ tex \mathtt{void} }}
| * :: :: prod {{ tex \times }}
| \ :: :: lambda {{ tex \lambda }}
| fix :: :: fix {{ tex \mathsf{fix} }}
| prl :: :: prl {{ tex \cdot\mathtt l }}
| prr :: :: prr {{ tex \cdot\mathtt r }}
| let :: :: let {{ tex \mathsf{let} }}
| in :: :: In {{ tex \mathsf{in} }}
| if0 :: :: if0 {{ tex \mathsf{if0} }}
| halt :: :: halt {{ tex \mathsf{halt} }}
| \in :: :: in {{ tex \in }}
| |-F :: :: turnstileF {{ tex \vdash_\mathrm F }}
| |-K :: :: turnstileK {{ tex \vdash_\mathrm K }}

formula :: formula_ ::=
| judgement :: :: judgement
| a \in D :: :: inD {{ coq In [[a]] [[D]] }}
| G ( x ) = t :: :: inG {{ coq In ([[x]], [[t]]) [[G]] }}

defns
F :: 'F_' ::=

defn
D |-F t :: :: type :: 'type_' {{ com type formation }}
by

a \in D
------- :: var
D |-F a

--------- :: int
D |-F int

D |-F t1
D |-F t2
-------------- :: arr
D |-F t1 -> t2

D , a |-F t
--------------- :: all
D |-F all a . t

D |-F t1
D |-F t2
------------- :: prod
D |-F t1 * t2

defn
D ; G |-F v : t :: :: anv :: 'anv_' {{ com annotated typing }}
by

D ; G |-F u : t
----------------- :: ann
D ; G |-F u t : t

defn
D ; G |-F u : t :: :: value :: 'value_' {{ com typing }}
by

D |-F t
G ( x ) = t
--------------- :: var
D ; G |-F x : t

----------------- :: int
D ; G |-F i : int

D |-F t1
D ; G , x1 : t1 |-F v : t2
----------------------------------------------- :: lam
D ; G |-F \ ( x1 : t1 ) . v : t1 -> t2

D ; G |-F v1 : t1 -> t2
D ; G |-F v2 : t1
----------------------- :: app
D ; G |-F v1 v2 : t2

D ; G |-F v1 : t1
D ; G |-F v2 : t2
--------------------------- :: pair
D ; G |-F v1 * v2 : t1 * t2

D ; G |-F v : t1 * t2
--------------------- :: prl
D ; G |-F v prl : t1

D ; G |-F v : t1 * t2
--------------------- :: prr
D ; G |-F v prr : t2

D ; G |-F v1 : int
D ; G |-F v2 : int
----------------------- :: prim
D ; G |-F v1 p v2 : int

D ; G |-F v1 : int
D ; G |-F v2 : t
D ; G |-F v3 : t
---------------------------------- :: if0
D ; G |-F if0 ( v1 , v2 , v3 ) : t

defns
K :: 'K_' ::=

defn
D |-K t :: :: type :: 'type_' {{ com type formation }}
by

a \in D
------- :: var
D |-K a

--------- :: int
D |-K int

D |-K t
--------------- :: arr
D |-K t -> void

D |-K t1
D |-K t2
------------- :: prod
D |-K t1 * t2

defn
D ; G |-K v : t :: :: anv :: 'anv_' {{ com annotated typing }}
by
D ; G |-K u : t
----------------- :: ann
D ; G |-K u t : t

defn
D ; G |-K u : t :: :: value :: 'value_' {{ com typing }}
by

D |-K t
G ( x ) = t
--------------- :: var
D ; G |-K x : t

----------------- :: int
D ; G |-K i : int

D ; G , x : t |-K e
------------------------------------- :: Lam
D ; G |-K \ ( x : t ) . e : t -> void

D ; G |-K v1 : t1
D ; G |-K v2 : t2
--------------------------- :: pair
D ; G |-K v1 * v2 : t1 * t2

defn
D ; G |-K e :: :: term :: 'term_' {{ com term formation }}
by

D ; G |-K v : t
D ; G , x : t |-K e
------------------------ :: let
D ; G |-K let x = v in e

D ; G |-K v : t1 * t2
D ; G , x : t1 |-K e
---------------------------- :: prl
D ; G |-K let x = v prl in e

D ; G |-K v : t1 * t2
D ; G , x : t2 |-K e
---------------------------- :: prr
D ; G |-K let x = v prr in e

D ; G |-K v1 : int
D ; G |-K v2 : int
D ; G , x : int |-K e
------------------------------ :: prim
D ; G |-K let x = v1 p v2 in e

D ; G |-K v' : t -> void
D ; G |-K v : t
------------------------ :: app
D ; G |-K v' ( v )

D ; G |-K v : int
D ; G |-K e1
D ; G |-K e2
----------------------------- :: if0
D ; G |-K if0 ( v , e1 , e2 )

D ; G |-K v : t
---------------------- :: halt
D ; G |-K halt [ t ] v

parsing
t_all <= t_arr

